<script>
  import { onMount, onDestroy } from 'svelte';
  import PocketBase from 'pocketbase';

  const pb = new PocketBase('http://127.0.0.1:8090'); // Point to your PocketBase instance

  // Variables for handling data
  let userRequests = [];
  let ongoingEvents = [];
  let loadingUserRequests = true;
  let loadingEvents = true;

  // Fetch New User Requests
  async function fetchUserRequests() {
    try {
      loadingUserRequests = true;
      const result = await pb.collection('user_requests').getFullList();
      userRequests = result;
      loadingUserRequests = false;
    } catch (error) {
      console.error('Error fetching user requests:', error);
      loadingUserRequests = false;
    }
  }

  // Fetch Ongoing Events
  async function fetchOngoingEvents() {
    try {
      loadingEvents = true;
      const result = await pb.collection('events').getFullList({
        filter: 'status="ongoing"', // Filter for ongoing events
      });
      ongoingEvents = result;
      loadingEvents = false;
    } catch (error) {
      console.error('Error fetching ongoing events:', error);
      loadingEvents = false;
    }
  }

  // Approve or Reject User Requests
  async function approveUser(id) {
    try {
      await pb.collection('user_requests').update(id, { status: 'approved' });
      await fetchUserRequests(); // Refresh list after approving
    } catch (error) {
      console.error('Error approving user:', error);
    }
  }

  async function rejectUser(id) {
    try {
      await pb.collection('user_requests').update(id, { status: 'rejected' });
      await fetchUserRequests(); // Refresh list after rejecting
    } catch (error) {
      console.error('Error rejecting user:', error);
    }
  }

  // Real-time subscriptions for user requests and events
  onMount(() => {
    fetchUserRequests();
    fetchOngoingEvents();

    const unsubscribeUserRequests = pb.collection('user_requests').subscribe('*', (e) => {
      fetchUserRequests(); // Refresh on updates
    });

    const unsubscribeEvents = pb.collection('events').subscribe('*', (e) => {
      fetchOngoingEvents(); // Refresh on updates
    });

    // Clean up subscriptions on component destroy
    onDestroy(() => {
      unsubscribeUserRequests();
      unsubscribeEvents();
    });
  });
</script>

<style>
  .dashboard {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    gap: 20px;
  }
  .card {
    padding: 20px;
    border-radius: 10px;
    background-color: #f9f9f9;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    flex: 1;
  }
  h2 {
    margin-bottom: 10px;
  }
  .loading {
    color: #aaa;
  }
  button {
    margin-right: 10px;
  }
</style>

<div class="dashboard">
  <!-- New User Requests Section -->
  <div class="card">
    <h2>New User Requests</h2>
    {#if loadingUserRequests}
      <p class="loading">Loading new user requests...</p>
    {:else}
      {#each userRequests as request (request.id)}
        <div class="request">
          <p><strong>Name:</strong> {request.name}</p>
          <p><strong>Email:</strong> {request.email}</p>
          <button on:click={() => approveUser(request.id)}>Approve</button>
          <button on:click={() => rejectUser(request.id)}>Reject</button>
        </div>
        <hr>
      {/each}
    {/if}
  </div>

  <!-- Ongoing Events Section -->
  <div class="card">
    <h2>Ongoing Events</h2>
    {#if loadingEvents}
      <p class="loading">Loading ongoing events...</p>
    {:else}
      {#each ongoingEvents as event (event.id)}
        <div class="event">
          <p><strong>Title:</strong> {event.title}</p>
          <p><strong>Description:</strong> {event.description}</p>
          <p><strong>Start Time:</strong> {new Date(event.start_time).toLocaleString()}</p>
        </div>
        <hr>
      {/each}
    {/if}
  </div>
</div>
